<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小笔记本</title>
  
  <subtitle>好风凭借力，送我上青云</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fibbery.github.io/"/>
  <updated>2019-08-20T10:27:36.248Z</updated>
  <id>https://fibbery.github.io/</id>
  
  <author>
    <name>Fibbery</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一次insert into on duplicate key upadte引发的问题</title>
    <link href="https://fibbery.github.io/2019/01/09/%E4%B8%80%E6%AC%A1insert%20into...on%20duplicate%20key%20upadte%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://fibbery.github.io/2019/01/09/一次insert into...on duplicate key upadte引发的问题/</id>
    <published>2019-01-09T09:05:51.000Z</published>
    <updated>2019-08-20T10:27:36.248Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>  最近有业务场景使用insert into … on duplicate key update进行插入更新操作，然后通过返回的affected rows来确定是进行了插入操作还是更新操作。印象中当不出现键冲突的时候affected rows应该为1（作用等同于insert into）, 而当键冲突的时候affected rows应该为2。但是实际情况是有键位冲突更新的时候affected rows返回的是1。  </p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>  首先我们梳理下表结构以及执行语句，业务表的设计大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="built_in">Record</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    user_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'用户id'</span>,</span><br><span class="line">    object_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'对方id'</span>,</span><br><span class="line">    create_time datetime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">now</span>() <span class="keyword">comment</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span> idx_user_object(<span class="string">`user_id`</span>,<span class="string">`object_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span> = <span class="keyword">innodb</span> <span class="keyword">comment</span> <span class="string">'记录表'</span></span><br></pre></td></tr></table></figure><p>实际执行的业务操作语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="built_in">Record</span>(user_id,object_id,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> <span class="keyword">set</span> create_time = <span class="keyword">now</span>()</span><br></pre></td></tr></table></figure><p>查了<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html" target="_blank" rel="noopener">MySQL Reference</a>可以发现是有对affected rows 进行说明的，内容如下:</p><blockquote><p>With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row, 2 if an existing row is updated, and 0 if an existing row is set to its current values. If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld, the affected-rows value is 1 (not 0) if an existing row is set to its current values.  </p></blockquote><p>也就是说当无主键冲突的时候affected row = 1；主键冲突的时候回去自定义更新记录 affected rows = 2；主键冲突但是自定义更新的值和原有值相同的时候affected rows = 0。如果mysql的参数CLIENT_FOUND_ROWS是设置成mysql_real_connect()，那么这种情况下也会返回1。那么问题很明显了，因为我们设置create_time是秒级别的，那么肯定存在一种情况，在你使用api连接mysql的时候加上参数CLIENT_FOUND_ROWS，在同一秒内A事务插入了一条记录返回affected rows = 1,B事务去执行更新的时候由于更新值和当前值相同导致返回affected rows = 1。</p><p>查询CLIENT_FOUND_ROWS发现如下解释：</p><blockquote><p>useAffectedRows<br>Don’t set the CLIENT_FOUND_ROWS flag when connecting to the server (not JDBC-compliant, will break most applications that rely on “found” rows vs. “affected rows” for DML statements), but does cause “correct” update counts from “INSERT … ON DUPLICATE KEY UPDATE” statements to be returned by the server.<br>Default: false<br>Since version: 5.1.7</p></blockquote><p>而默认jdbc是会默认传递CLIENT_FOUND_ROWS的，也就是返回的是寻找到的行，当然可以在连接参数上加上userAffectedRows=true来让其返回收影响的行</p><h2 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h2><p>直接在库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`Record`</span>(<span class="string">`user_id`</span>,<span class="string">`object_id`</span>,<span class="string">`create_time`</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2019-1-9 19:03:33'</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> create_time = <span class="string">'2019-1-9 19:03:33'</span></span><br></pre></td></tr></table></figure><p>返回<code>Query OK, 1 row affected</code>，接下来继续执行相同的语句，返回<code>Query OK, 0 rows affected</code>，意味着情况和文档描述的一样。我们通过jdbc直接操作会发现第二次执行语句时是会返回affected rows = 1的，在连接字符串上加上useAffectedRows是会发现返回的是affected rows = 0 </p><blockquote><p>注意<br>如果使用了mycat中间件的话，在连接字符串加useAffectedRow也没设么用，因为mycat默认配置的就是CLIENT_FOUND_ROWS<br><img src="/assets/blogImg/mycat-img01.jpg" alt="代码结构"><br></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;  最近有业务场景使用insert into … on duplicate key update进行插入更新操作，然后通过返回的affected rows来确定是进行了插入操作还是更新操作。印象中当不出现键冲突的时候affected rows应该为1（作用等同于insert into）, 而当键冲突的时候affected rows应该为2。但是实际情况是有键位冲突更新的时候affected rows返回的是1。  &lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="https://fibbery.github.io/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建mysql双主配置</title>
    <link href="https://fibbery.github.io/2018/05/10/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E5%8F%8C%E4%B8%BB%E9%85%8D%E7%BD%AE/"/>
    <id>https://fibbery.github.io/2018/05/10/使用docker搭建mysql双主配置/</id>
    <published>2018-05-10T02:23:53.000Z</published>
    <updated>2019-08-20T10:27:28.708Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网架构需要保证数据库高可用，常见的一种方式，使用双主同步+keepalived+虚ip的方式保证数据库的可用性。依照前文<a href="https://fibbery.me/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">使用docker搭建mysql简单主从集群</a> 想尝试一下使用docker搭建会有什么问题</p><a id="more"></a><h2 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h2><ol><li><p>搭建好docker网络<br> 因为需要两个容器互联，所以需要使用docker连创建互联网络，参见<a href="http://www.up4dev.com/2016/10/09/docker-network-create/" target="_blank" rel="noopener">用network create解决Docker容器互相连接的问题</a><br> </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net  # 先创建一个网络</span><br><span class="line">docker network ls # 查看一下是否创建成功</span><br></pre></td></tr></table></figure></li><li><p>新建masterA库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /data/mysqlcnf/masterA:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name masterA --net=my-net --net-alias=masterA mysql   # 利用自建网络搭建主库A</span><br></pre></td></tr></table></figure><p> 数据库配置文件如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server-id                = 1</span><br><span class="line">auto_increment_offset    = 1</span><br><span class="line">auto_increment_increment = 1</span><br><span class="line"></span><br><span class="line">log_bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">log-slave-updates      = true</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">lower_case_table_names = 1</span><br></pre></td></tr></table></figure><p> 因为是互为主从，所以auto_increment_offset(起始位移点)和auto_increment_increment(步长)必须间隔设置，同时必须开启log-slave-updates设置，前文有提到过。</p><p> 重启masterA库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart masterA</span><br></pre></td></tr></table></figure></li><li><p>新建masterB 主库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/masterB:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name masterB --net=my-net --net-alias=masterB mysql  # 利用自建网络搭建主库B</span><br></pre></td></tr></table></figure><p> 数据库配置文件如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id                = 2</span><br><span class="line">auto_increment_offset    = 2</span><br><span class="line">auto_increment_increment = 2</span><br><span class="line"></span><br><span class="line">log_bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">log-slave-updates      = true</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">lower_case_table_names = 1</span><br></pre></td></tr></table></figure><p> 重启B库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart masterB</span><br></pre></td></tr></table></figure></li><li><p>配置数据库帐号以及主从配置<br> 分别登录masterA和masterB添加从库同步帐号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'sync'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'sync'</span>  # 新建同步帐号</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span> # 刷新权限缓存</span><br></pre></td></tr></table></figure><p> 分别执行查看masterA和masterB的binlog情况</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure><p> 分别进行主从同步<br> ```sql</p><pre><code>change master to master_host=&apos;${host}&apos;,master_port=&apos;${port}&apos;,master_user= &apos;${master_user}&apos; ,master_password=&apos;${master_password}&apos;,master_log_file=&apos;${master_log_file}&apos;,master_log_pos=&apos;${master_log_pos}&apos;start slaveshow slave status\G</code></pre><p> ```　<br> 以上sql都可以观看前文得知，不再赘述。到此，双主mysql集群搭建完成。</p></li></ol><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;互联网架构需要保证数据库高可用，常见的一种方式，使用双主同步+keepalived+虚ip的方式保证数据库的可用性。依照前文&lt;a href=&quot;https://fibbery.me/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;使用docker搭建mysql简单主从集群&lt;/a&gt; 想尝试一下使用docker搭建会有什么问题&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="https://fibbery.github.io/tags/mysql/"/>
    
      <category term="docker" scheme="https://fibbery.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用docker搭建mysql简单主从集群</title>
    <link href="https://fibbery.github.io/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
    <id>https://fibbery.github.io/2018/05/09/使用docker搭建mysql简单主从集群/</id>
    <published>2018-05-09T12:32:37.000Z</published>
    <updated>2019-08-20T10:27:20.223Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近对mysql集群搭建以及后期如何在线上进行拆分和迁移产生了兴趣，所以初步想在自己本机通过docker搭建一个简单的主从集群来满足一下好奇心</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>OS X EI Capitan 10.11.6<br>docker版本17.09.0-ce-mac35 (19611)<br>mysql镜像版本5.7(这里我直接下载的标签为latest的最新版本)</p><h2 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h2><h3 id="建立主库容器"><a href="#建立主库容器" class="headerlink" title="建立主库容器"></a>建立主库容器</h3><ol><li><p>建立主数据库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name master mysql</span><br></pre></td></tr></table></figure></li><li><p>在本机目录/data/mysqlcnf/master中新建mysql数据库配置文件my.cnf，内容如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id                = 1</span><br><span class="line">log_bin                  = mysql-bin</span><br><span class="line">binlog-format            = ROW</span><br><span class="line">lower_case_table_names   = 1</span><br></pre></td></tr></table></figure><p> 需要注意下mysql镜像自带是有配置文件的，我们映射过来的文件夹并不能完全覆盖，所以不要让配置文件冲突</p></li><li><p>重启容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart master</span><br></pre></td></tr></table></figure></li><li><p>建立授权帐号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'sync'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'sync'</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span></span><br></pre></td></tr></table></figure></li><li><p>查询下主库当前binlog情况</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure><p> 记录下file和position，等到设置从库时需要</p></li></ol><h3 id="建立从库容器"><a href="#建立从库容器" class="headerlink" title="建立从库容器"></a>建立从库容器</h3><ol><li><p>建立从数据库(使用link实现从库连接主库)</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name slave --link master:master mysql</span><br></pre></td></tr></table></figure></li><li><p>从库配置文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id              = 2</span><br><span class="line"></span><br><span class="line">log-bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">log-slave-updates      = 1</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">read-only              = 1</span><br></pre></td></tr></table></figure><p> log-slave-updates参数的意义在于，如果该库是从库，从主库binlog读取的更新是不会继续写入该库的binlog，设置该参数后则可以实现读取主库binlog之后写入自己库的binlog，用来做其他从库的主库</p></li><li><p>重启容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart slave</span><br></pre></td></tr></table></figure></li><li><p>登录从库服务器设置主库</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'master'</span>,MASTER_USER=<span class="string">'sync'</span>, MASTER_PASSWORD=<span class="string">'sync'</span>,MASTER_LOG_FILE=<span class="string">'mysql-bin.000005'</span>, MASTER_LOG_POS=<span class="number">154</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br></pre></td></tr></table></figure><p> 这里设置的值master_log_file以及master_log_pos根据当初查询主库得来</p></li><li><p>查看从库状态</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure></li></ol><p>至此简单的mysql的主从集群搭建完成</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近对mysql集群搭建以及后期如何在线上进行拆分和迁移产生了兴趣，所以初步想在自己本机通过docker搭建一个简单的主从集群来满足一下好奇心&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="mysql" scheme="https://fibbery.github.io/tags/mysql/"/>
    
      <category term="docker" scheme="https://fibbery.github.io/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>Java序列化的一些了解</title>
    <link href="https://fibbery.github.io/2018/03/06/Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%86%E8%A7%A3/"/>
    <id>https://fibbery.github.io/2018/03/06/Java序列化的一些了解/</id>
    <published>2018-03-06T15:53:54.000Z</published>
    <updated>2019-08-20T10:28:27.728Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>通常来说序列化和反序列化通常是一起的。我们常见的就是你只要将类实现Serializable接口，就能将该类的对象序列化二进制文件，同时能通过反序列化将二进制文件还原成对象。<br><a id="more"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我们通过Demo来了解Java序列化和反序列化的具体情况，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7303637756547202487L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//进行序列化到二进制文件中</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"out"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(<span class="keyword">new</span> Test());</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">//从二进制文件中反序列化成对象</span></span><br><span class="line">        ObjectInputStream ins = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        Test o = (Test) ins.readObject();</span><br><span class="line">        ins.close();</span><br><span class="line">        System.out.println(o.staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对以上Demo可以知道Java的序列化和反序列化其实就是使用ObjectInputStream和ObjectInputStream对实现了Serializable类的读写。深入代码可以发现，在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p><h2 id="序列化的特点"><a href="#序列化的特点" class="headerlink" title="序列化的特点"></a>序列化的特点</h2><ol><li>如果某个类可以被序列化，其子类也可以被序列化。但是如果子类实现序列化，父类没有，那么子类反序列化会将父类那部分属性丢失。</li><li>声明为static和transient类型的成员数据不能被序列化，因为static代表类的状态，而transient代表对象的临时数据。</li><li>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</li></ol><p>根据第三点使用Demo详细说明下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8386243968193725155L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference();</span><br><span class="line">        reference.setName(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"reference"</span>);</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        os.writeObject(reference);</span><br><span class="line">        <span class="comment">//reference.setName("python")   ---- 展现特性的情况</span></span><br><span class="line">        os.writeObject(reference); <span class="comment">//再次写入</span></span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        Reference reference1 = (Reference) is.readObject();</span><br><span class="line">        Reference reference2 = (Reference) is.readObject();</span><br><span class="line">        System.out.println(reference1 == reference2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果是true，同时比较写入一个对象的文件大小和写入两次相同对象文件的大小，发现没有呈2倍关系，证明其实第二次写入的只是一个引用而已。同时我们释放Demo的特性情况注释，发现结果还是True，说明在写入第一个对象之后，虽然改变了对象的成员变量，但是成员地址没有发生改变，虚拟机在进行第二次写入的时候，发现了一个相同的对象(地址相同)已经写入文件，因此只保存了一个引用，所以读取时，返回的仍然是第一次的对象。</p><blockquote><p>使用一个文件多次writeObject的时候需要注意这个问题</p></blockquote><h2 id="一些序列化的特性以及对应场景"><a href="#一些序列化的特性以及对应场景" class="headerlink" title="一些序列化的特性以及对应场景"></a>一些序列化的特性以及对应场景</h2><h3 id="序列化ID的作用"><a href="#序列化ID的作用" class="headerlink" title="序列化ID的作用"></a>序列化ID的作用</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。因此为了实现序列化接口的实体能够兼容先前版本，最好显式地定义一个名为serialVersionUID类型为long的变量，这样就不会存在版本不一致的问题。<br>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><h4 id="应对场景"><a href="#应对场景" class="headerlink" title="应对场景"></a>应对场景</h4><p>Java中RMI(Remoting Method Inovke)的实现</p><h3 id="父类序列化和Transient关键字"><a href="#父类序列化和Transient关键字" class="headerlink" title="父类序列化和Transient关键字"></a>父类序列化和Transient关键字</h3><h4 id="由来-1"><a href="#由来-1" class="headerlink" title="由来"></a>由来</h4><blockquote><p>参见<a href="#序列化的特点">序列化特点</a></p></blockquote><h4 id="应对场景-1"><a href="#应对场景-1" class="headerlink" title="应对场景"></a>应对场景</h4><p>平常我们都是使用transient关键字使字段不被序列化，但是如果有过多相同的类有同样的字段不需要序列化，我们可以将这些成员变量抽出来做成虚基类，根据父类对象序列化的规则，只要父类不实现Serializable接口，这写成员变量都不会被序列化。</p><h3 id="敏感字段加密"><a href="#敏感字段加密" class="headerlink" title="敏感字段加密"></a>敏感字段加密</h3><h4 id="由来-2"><a href="#由来-2" class="headerlink" title="由来"></a>由来</h4><blockquote><p>参见<a href="#具体实现">具体实现</a></p></blockquote><h4 id="应对场景-2"><a href="#应对场景-2" class="headerlink" title="应对场景"></a>应对场景</h4><p>一些敏感信息不便于传输，可以对敏感字段进行加密，只有正确的客户端和服务端能加密和解密，避免传输过程中泄漏。因此可以在对象里自定义writeObject 和 readObject 方法，这样就可以完全控制对象序列化的过程，从而可以在序列化的过程中对某些数据进行加解密操作。<br>Demo代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5790119844861945929L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"pass"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream.PutField field = os.putFields();</span><br><span class="line">            System.out.println(<span class="string">" 原始密码: "</span> + password);</span><br><span class="line">            String encryptedPass = encrypt(password);<span class="comment">//伪码模拟加密</span></span><br><span class="line">            field.put(<span class="string">"password"</span>, encryptedPass); </span><br><span class="line">            os.writeFields();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream.GetField field = is.readFields();</span><br><span class="line">            Object encryptPass = field.get(<span class="string">"password"</span>, <span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"获取加密的字符串："</span> + encryptPass);</span><br><span class="line">            String decryptPass = decryptPass(encryptPass); <span class="comment">//伪码模拟解密</span></span><br><span class="line">            password = decryptPass; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"password"</span>)));</span><br><span class="line">        os.writeObject(<span class="keyword">new</span> Account());</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"password"</span>)));</span><br><span class="line">        Account o = (Account) is.readObject();</span><br><span class="line">        System.out.println(<span class="string">"解密后的密码是："</span> + o.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.<a href="http://blog.csdn.net/jiangwei0910410003/article/details/18989711" target="_blank" rel="noopener">Java中的序列化Serialable高级详解</a><br>2.<a href="http://www.oschina.net/question/4873_23270" target="_blank" rel="noopener">Java序列化的作用</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h2&gt;&lt;p&gt;通常来说序列化和反序列化通常是一起的。我们常见的就是你只要将类实现Serializable接口，就能将该类的对象序列化二进制文件，同时能通过反序列化将二进制文件还原成对象。&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java" scheme="https://fibbery.github.io/tags/java/"/>
    
      <category term="serializable" scheme="https://fibbery.github.io/tags/serializable/"/>
    
  </entry>
  
  <entry>
    <title>Dubbo通信实现</title>
    <link href="https://fibbery.github.io/2018/03/03/Dubbo%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/"/>
    <id>https://fibbery.github.io/2018/03/03/Dubbo通信实现/</id>
    <published>2018-03-03T13:28:03.000Z</published>
    <updated>2019-08-20T10:06:14.663Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>基于dubbo默认通讯服务器Netty来解析服务端和客户端如何通讯<br><a id="more"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><p>首先我们看下协议接口类Protocol中暴露服务的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露远程调用服务：</span></span><br><span class="line"><span class="comment"> * 1. 该通信协议必须在接到请求之后记录请求的源地址：</span></span><br><span class="line"><span class="comment"> *RpcContext.getContext().setRemoteAddress()</span></span><br><span class="line"><span class="comment"> * 2. export必须是幂等的。意味着使用相同的URL不论是调用一次还是调用两次，结果都是一样的</span></span><br><span class="line"><span class="comment"> * 3. invoker实例是由框架实现的，跟协议没任何关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> T 服务的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker 服务实现的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回被暴露服务实例的引用，用于取消服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p>然后我们看分析dubbo协议的暴露服务的具体实现DubboProtocol.export的过程如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export ---&gt; openServer ---&gt; createServer ---&gt;  Exchangers.bind(url,handler)</span><br></pre></td></tr></table></figure><p>openServer根据invoker携带的URL信息获取host以及ip，如果已经存在，则不会创建服务。<br>然后我们继续看下<em>Exchanger</em>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">       <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><em>getExchanger(url)</em>典型的策略模式，得到HeaderExchanger，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li><em>HeaderExchangeServer</em>其实是真正server的包裹类，提供了server的一些操作接口已经对server的一个心跳检测功能。</li><li>Transporters.bind这一步就是根据url选择对应的通信框架开启服务(此例中采用NettyTransport)。</li><li>new DecodeHandler(new HeaderExchangeHandler(handler)))采用装饰器模式构造服务端通道的handler</li></ol><blockquote><p>此处不讨论DecodeHandler如何对该协议通道的信息decode以及encode的过程</p></blockquote><h3 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h3><p>我们看下Protocol中引用服务的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用远程服务</span></span><br><span class="line"><span class="comment">     * 1.当使用者调用invoker(通信协议使用refer方法生成)的invoke方法的时候，通信协议</span></span><br><span class="line"><span class="comment">     * 会相应的让服务端对应的invoker调用invoke方法。</span></span><br><span class="line"><span class="comment">     * 2.refer返回的invoker实例是由通信协议生成实现的。实现的过程只不过是将方法调用的过程</span></span><br><span class="line"><span class="comment">     * 封装成用远程请求的方式。</span></span><br><span class="line"><span class="comment">     * 3.当URL设置check=false的时候，客户端不应该在连接服务端失败的时候抛出异常，并且有</span></span><br><span class="line"><span class="comment">     * 义务尝试重连</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 远程服务的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 远程服务类的class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 远程服务的url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker 远程服务的本地代理实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p>我们还是通过DubboProtocol来看客户端如何实现远程调用，refer方法在初始的时候会初始化一个与对应远端的连接，同时返回持有这个连接的对象invoker。我们需要将其转换成对应需要使用的服务类，在这里就需要用到动态代理这样的一个方式来生成一个本地句柄，以便客户端像调用本地服务一样调用。所以，一般客户端使用如下(伪码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line">DemoService service = proxyFactory.getProxy(refer(type,url)); <span class="comment">//本地生成代理类</span></span><br><span class="line">service.echo(); <span class="comment">//调用方法</span></span><br></pre></td></tr></table></figure><p>接下来我们具体看JavassistProxyFactory是怎么生成一个客户端需要的代理类的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>InvokerInvocationHandler这个类是很明显的装饰器模式，让属于Object类中的方法以及toString、hashCode、equals一些通用方法只在本地调用，实际上我们还是使用的DubboInvoker的invoker方法，也就是其中具体的doInvoke方法。代码点实现也只是使用返回的invoker对象中持有的客户端连接来发送请求消息，获取返回结果。</p><blockquote><p>dubbo暴露方法和对远程方法的调用可以阅读源码DubboProtocolTest.testDemoProtocol来了解</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前提&quot;&gt;&lt;a href=&quot;#前提&quot; class=&quot;headerlink&quot; title=&quot;前提&quot;&gt;&lt;/a&gt;前提&lt;/h2&gt;&lt;p&gt;基于dubbo默认通讯服务器Netty来解析服务端和客户端如何通讯&lt;br&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="dubbo - netty - java" scheme="https://fibbery.github.io/tags/dubbo-netty-java/"/>
    
  </entry>
  
  <entry>
    <title>OpenSSL生成根证书CA</title>
    <link href="https://fibbery.github.io/2018/02/06/OpenSSL%E7%94%9F%E6%88%90%E6%A0%B9%E8%AF%81%E4%B9%A6CA/"/>
    <id>https://fibbery.github.io/2018/02/06/OpenSSL生成根证书CA/</id>
    <published>2018-02-06T02:38:49.000Z</published>
    <updated>2019-08-20T10:28:34.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>本机Mac，所以只讨论Mac环境下的生成方法。<br>需要安装openssl，如果没有可以使用homebrew安装。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><blockquote><p>以下所有[]中的内容代表可选项目</p></blockquote><h3 id="生成根证书CA"><a href="#生成根证书CA" class="headerlink" title="生成根证书CA"></a>生成根证书CA</h3><h4 id="1-生成根证书私钥"><a href="#1-生成根证书私钥" class="headerlink" title="1)生成根证书私钥"></a>1)生成根证书私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa [-aes256] -out ca_private.pem 2048</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>genrsa 表示使用rsa算法产生私钥</li><li>2048 表示私钥长度</li><li>-aes256表示使用256位的AES算法对密钥进行加密，另外还有des3</li></ul><h4 id="2-生成根证书请求文件"><a href="#2-生成根证书请求文件" class="headerlink" title="2)生成根证书请求文件"></a>2)生成根证书请求文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca_private.pem -out ca.csr -subj "/C=CN/ST=Guangdong/L=Shenzhen/O=Zhenai/OU=Java/CN=HttpProxy"</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>req 表示执行证书签发命令</li><li>new 表示新证书签发请求</li><li>key 指定证书私钥路径</li><li>out表示输出的证书请求文件的位置</li><li>subj表示证书相关的用户信息</li></ul><h4 id="3-自签发根证书"><a href="#3-自签发根证书" class="headerlink" title="3)自签发根证书"></a>3)自签发根证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 [-sha1] [-extfile openssl.cnf] [-extensions v3_ca] -signkey ca_private.pem -in ca.csr -out ca.crt</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>x509表示生成x509格式证书</li><li>req 表示输入csr文件</li><li>days 表示证书有效期(天)</li><li>sha1表示证书的摘要使用sha1</li><li>extensions 表示安装openssl.conf文件中配置的v3_ca项添加拓展</li><li>extfile 表示配置文件，下方有提供。</li><li>signkey 表示签发证书使用的私钥</li></ul><h3 id="用根证书签发server端证书"><a href="#用根证书签发server端证书" class="headerlink" title="用根证书签发server端证书"></a>用根证书签发server端证书</h3><h4 id="1-生成服务端私钥"><a href="#1-生成服务端私钥" class="headerlink" title="1)生成服务端私钥"></a>1)生成服务端私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_private.pem 2048</span><br></pre></td></tr></table></figure><h4 id="2-生成证书请求文件"><a href="#2-生成证书请求文件" class="headerlink" title="2)生成证书请求文件"></a>2)生成证书请求文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_private.pem -out server.csr -subj "/C=CN/ST=Guangdong/L=Shenzhen/O=Zhenai/OU=Java/CN=HttpProxy"</span><br></pre></td></tr></table></figure><h4 id="3-利用根证书签发服务端证书"><a href="#3-利用根证书签发服务端证书" class="headerlink" title="3)利用根证书签发服务端证书"></a>3)利用根证书签发服务端证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 [-sha256] [-extfile openssl.conf] [-extensions v3_req] -CA ca.crt -CAkey ca_private.pem -CAserial ca.srl -CAcreateserial -in server.csr -out server.crt</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>CA 指定ca证书</li><li>CAkey指定证书的私钥</li><li>CAserial 指定证书序列号文件</li><li>表示创建证书序列号文件(即上方提到的serial文件)，创建的序列号文件默认名称为-CA，指定的证书名称后加上.srl后缀。<blockquote><p>注意这里的是<strong>-extensions v3_req</strong> </p></blockquote></li></ul><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><ol><li><p>上面过程中生成的私钥是不能直接被java读取的，只能通过下述命令转换一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -nocrypt -inform PEM -outform PEM -in ca_private.pem  -out ca_private_pkcs8.pem</span><br></pre></td></tr></table></figure></li><li><p>curl使用证书的时候必须是pem格式的，crt到pem格式转换如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in ca.crt -out ca.pem -text</span><br></pre></td></tr></table></figure></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>openssl.conf文件下载：<a href="/assets/file/openssl.conf">下载文件</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;准备环境&quot;&gt;&lt;a href=&quot;#准备环境&quot; class=&quot;headerlink&quot; title=&quot;准备环境&quot;&gt;&lt;/a&gt;准备环境&lt;/h2&gt;&lt;p&gt;本机Mac，所以只讨论Mac环境下的生成方法。&lt;br&gt;需要安装openssl，如果没有可以使用homebrew安装。&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;brew install openssl&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="openssl" scheme="https://fibbery.github.io/tags/openssl/"/>
    
      <category term="https" scheme="https://fibbery.github.io/tags/https/"/>
    
      <category term="证书" scheme="https://fibbery.github.io/tags/%E8%AF%81%E4%B9%A6/"/>
    
  </entry>
  
  <entry>
    <title>java读取openssl创建的公私钥</title>
    <link href="https://fibbery.github.io/2018/01/19/java%E8%AF%BB%E5%8F%96openssl%E5%88%9B%E5%BB%BA%E7%9A%84%E5%85%AC%E7%A7%81%E9%92%A5/"/>
    <id>https://fibbery.github.io/2018/01/19/java读取openssl创建的公私钥/</id>
    <published>2018-01-19T10:38:12.000Z</published>
    <updated>2019-08-20T10:28:16.085Z</updated>
    
    <content type="html"><![CDATA[<p>最近在考虑使用Netty搭建HTTP/HTTPS代理服务器，遇到了openssl密钥读取问题，下面概述步骤。<br>选用openssl生成密钥的初衷是netty的SslContextBuilder对其支持比较直接，相较于使用keytool更为容易读取。</p><a id="more"></a><h2 id="公私钥以及证书的生成"><a href="#公私钥以及证书的生成" class="headerlink" title="公私钥以及证书的生成"></a>公私钥以及证书的生成</h2><p>openssl工具生成十分简单，只概叙其命令步骤<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> 生成私钥</span><br><span class="line">1. openssl genrsa -out rsa_private_key.pem 1024</span><br><span class="line"><span class="meta">#</span> 根据私钥生成公钥</span><br><span class="line">2. openssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -outform PEM -pubout  </span><br><span class="line"><span class="meta">#</span> java不能直接读取该私钥，需要转换成pkcs8格式</span><br><span class="line">3. openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem</span><br><span class="line"><span class="meta">#</span> 根据私钥创建证书请求</span><br><span class="line">4. openssl req -new -key rsa_private_key.pem -out rsa_public_key.csr</span><br><span class="line"><span class="meta">#</span> 生成证书并且签名</span><br><span class="line">5. openssl x509 -req -days 3650 -in rsa_public_key.csr -signkey rsa_private_key.pem -out rsa_public_key.crt</span><br></pre></td></tr></table></figure></p><h3 id="java读取私钥以及公钥"><a href="#java读取私钥以及公钥" class="headerlink" title="java读取私钥以及公钥"></a>java读取私钥以及公钥</h3><p>文本打开公私钥，可以发现格式都是如下类似格式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY-----</span><br><span class="line">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5M2njgC84dLEvMHNHEmZMhtYx</span><br><span class="line">w7ncLjZQIyAHyGfruJqTksdJ16V1eRNN3pEn17QAOk6Y3pPjyH/+Meir2iK9GGyB</span><br><span class="line">L9Yvli0eo5xMcLv1XmLeLgQ1EFetRj6i4jTtvaIAIb0uAG3XHHqmQRD6+nLnqV5E</span><br><span class="line">f3iHyXNfo12Y7bjbbwIDAQAB</span><br><span class="line">-----END PUBLIC KEY-----</span><br></pre></td></tr></table></figure></p><p>可以看出导出的文本都是Base64编码的字符串，我们只需要读入有效字符串，然后实例化成具体实体即可。</p><ol><li><p>读取文本字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readKeyStr</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) != <span class="string">'-'</span>) &#123;</span><br><span class="line">                buffer.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>base64解码成真正的密钥字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br></pre></td></tr></table></figure></li><li><p>实例化成具体密钥实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RSAPublicKey <span class="title">loadPublicKey</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"rsa"</span>);</span><br><span class="line">        X509EncodedKeySpec spec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        <span class="keyword">return</span> (RSAPublicKey) factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RSAPrivateKey <span class="title">loadPrivateKey</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"rsa"</span>);</span><br><span class="line">        PKCS8EncodedKeySpec spec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        <span class="keyword">return</span> (RSAPrivateKey) factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在考虑使用Netty搭建HTTP/HTTPS代理服务器，遇到了openssl密钥读取问题，下面概述步骤。&lt;br&gt;选用openssl生成密钥的初衷是netty的SslContextBuilder对其支持比较直接，相较于使用keytool更为容易读取。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://fibbery.github.io/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="openssl" scheme="https://fibbery.github.io/tags/openssl/"/>
    
      <category term="rsa" scheme="https://fibbery.github.io/tags/rsa/"/>
    
  </entry>
  
</feed>
