<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>jvm字节码入门</title>
      <link href="/2019/09/19/jvm%E5%AD%97%E8%8A%82%E7%A0%81%E5%85%A5%E9%97%A8/"/>
      <url>/2019/09/19/jvm%E5%AD%97%E8%8A%82%E7%A0%81%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>java为什么能”一次编译，多次运行“，因为java在任何环境下，通过编译都能生成一种固定格式的字节码（.class）文件。之所以被称之为字节码，是因为字节码文件由十六进制值组成，而JVM以两个十六进制值为一组，即以字节为单位进行读取。<br><a id="more"></a><br>以下是java文件从编译到运行的具体流程：<br> <img src="/assets/blogImg/bytecode_running.jpg" alt="jvm编译运行图"><br>所以我们从字节码文件说起，一次去探究代码如何run起来的</p><h2 id="字节码文件认识"><a href="#字节码文件认识" class="headerlink" title="字节码文件认识"></a>字节码文件认识</h2><h3 id="文件初览"><a href="#文件初览" class="headerlink" title="文件初览"></a>文件初览</h3><p>.java文件编译后生产.class文件。新建一个源码文件如下：<br><img src="/assets/blogImg/HelloJava.jpg" alt="HelloJava源代码"><br>使用xxd查看生成的16进制文件Hello.class，如下<br><img src="/assets/blogImg/HelloJavaByteCode.jpg" alt="HelloJavaByteCode"><br>文件结构可以通过<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html" target="_blank" rel="noopener">JVM虚拟机规范</a>得到，大致如下：<br><img src="/assets/blogImg/ClassFileStructure.jpg" alt="ClassFile Structure"></p><blockquote><ol><li>第一列表示字段的类型，第二列是该字段的名称；</li><li>U2、U4分别代表占用2字节和4个字节</li><li>_info结尾的代表class文件中的表，表也是由若干个无符号数和若干个表构成，用来表示复杂一些的class内容；</li><li>整个class文件就是一个大的表；</li></ol></blockquote><ol><li>MAGIC (魔法数) 0xCAFEBABE </li><li>版本号 0000 0034   （十进制52）</li><li>0022  常量池 （十进制34，排除掉下标0的，只有33个）<br>…</li></ol><h3 id="字节码查看"><a href="#字节码查看" class="headerlink" title="字节码查看"></a>字节码查看</h3><h4 id="自带工具类"><a href="#自带工具类" class="headerlink" title="自带工具类"></a>自带工具类</h4><p>上述方式对我们看字节码具体内容并不是十分友好，所以自带的工具类javap可以让我们十分便利的通过字节码文件了解到类的实现细节。javap使用help如下：<br><img src="/assets/blogImg/javapusage.jpg" alt="javap help"><br>我们通过<figure class="highlight plain"><figcaption><span>-v Hello.class```可以得到如下结果：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line">Classfile /Users/fibbery/Documents/workspace/demo/src/main/java/com/fibbery/demo/jvm/Hello.class</span><br><span class="line">  Last modified 2019-9-19; size 518 bytes</span><br><span class="line">  MD5 checksum d28a8ac83ec1ee573714d295476cf07b</span><br><span class="line">  Compiled from &quot;Hello.java&quot;</span><br><span class="line">public class Hello</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #6.#20         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Fieldref           #21.#22        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #3 = String             #23            // Hello World</span><br><span class="line">   #4 = Methodref          #24.#25        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #26            // Hello</span><br><span class="line">   #6 = Class              #27            // java/lang/Object</span><br><span class="line">   #7 = Utf8               &lt;init&gt;</span><br><span class="line">   #8 = Utf8               ()V</span><br><span class="line">   #9 = Utf8               Code</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               LHello;</span><br><span class="line">  #14 = Utf8               main</span><br><span class="line">  #15 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #16 = Utf8               args</span><br><span class="line">  #17 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               SourceFile</span><br><span class="line">  #19 = Utf8               Hello.java</span><br><span class="line">  #20 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #21 = Class              #28            // java/lang/System</span><br><span class="line">  #22 = NameAndType        #29:#30        // out:Ljava/io/PrintStream;</span><br><span class="line">  #23 = Utf8               Hello World</span><br><span class="line">  #24 = Class              #31            // java/io/PrintStream</span><br><span class="line">  #25 = NameAndType        #32:#33        // println:(Ljava/lang/String;)V</span><br><span class="line">  #26 = Utf8               Hello</span><br><span class="line">  #27 = Utf8               java/lang/Object</span><br><span class="line">  #28 = Utf8               java/lang/System</span><br><span class="line">  #29 = Utf8               out</span><br><span class="line">  #30 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #31 = Utf8               java/io/PrintStream</span><br><span class="line">  #32 = Utf8               println</span><br><span class="line">  #33 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">&#123;</span><br><span class="line">  public Hello();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LHello;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: getstatic     #2                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #3                  // String Hello World</span><br><span class="line">         5: invokevirtual #4                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       9     0  args   [Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Hello.java&quot;</span><br></pre></td></tr></table></figure></p><h4 id="其他工具类"><a href="#其他工具类" class="headerlink" title="其他工具类"></a>其他工具类</h4><p>但是每次都通过javap看字节码有需要重复很多无用的工作，一个Idea插件：<a href="https://plugins.jetbrains.com/plugin/9248-jclasslib-bytecode-viewer" target="_blank" rel="noopener">jclasslib</a>。代码编译后在菜单栏”View”中选择”Show Bytecode With jclasslib”，可以很直观地看到当前字节码的一些信息。<br><img src="/assets/blogImg/jclasslib.jpg" alt="jclasslib查看字节码"><br></p><h3 id="常见的指令"><a href="#常见的指令" class="headerlink" title="常见的指令"></a>常见的指令</h3><p>从上述字节码可以看到很多的指令使用，我们从<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.getstatic" target="_blank" rel="noopener">The Java Virtual Machine Instruction Set</a>是可以知道指令具体的动作是什么，接下来挑选几个作为实例讲解</p><h4 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h4><p>方法调用指令分为5个：</p><ol><li>invokestatic：用于调用静态方法</li><li>invokespecial：用于调用私有实例方法、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法</li><li>invokevirtual：用于调用非私有实例方法（即public protected pacakge)</li><li>invokeinterface：用于调用接口方法</li><li>invokedynamic：用于调用动态方法</li></ol><h2 id="字节码运行原理"><a href="#字节码运行原理" class="headerlink" title="字节码运行原理"></a>字节码运行原理</h2><h3 id="虚拟机结构"><a href="#虚拟机结构" class="headerlink" title="虚拟机结构"></a>虚拟机结构</h3><p>jvm虚拟机结构如下：<br><img src="/assets/blogImg/JvmMemoryStructure.jpg" alt="jvm内存结构"><br>其中的Java虚拟机栈(Java Virtual Machine Stacks)也是线程私有的,它的生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程,就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构 栈帧随着方法调用而创建，随着方法结束而销毁，栈帧的存储空间分配在 Java 虚拟机栈中，每个栈帧拥有自己的<strong>局部变量表(Local Variables)</strong>、<strong>操作数栈(Operate Stack)</strong> 以及 <strong>指向运行时常量池的引用</strong>，如下图所示：<br><img src="/assets/blogImg/StackFrame.jpg" alt="StackFrame"></p><ul><li>局部变量表：每个栈帧内部都包含一组称为局部变量表（Local Variables）的变量列表，局部变量表的大小在编译期间就已经确定。Java 虚拟机使用局部变量表来完成方法调用时的参数传递，当一个方法被调用时，它的参数会被传递到从 0 开始的连续局部变量列表位置上。当一个实例方法（非静态方法）被调用时，第 0 个局部变量是调用这个实例方法的对象的引用（也就是我们所说的 this ）</li><li>操作数栈：每个栈帧内部都包含了一个称为操作数栈的后进先出（LIFO）栈，栈的大小同样也是在编译期间确定。Java 虚拟机提供的一些字节码指令用来从局部变量表或者对象实例的字段中复制常量或者变量到操作数栈，也有一些指令用于从操作数栈取走数据、操作数据和把操作结果重新入栈。在方法调用时，操作数栈也用来准备调用方法的参数和接收方法返回的结果。<br>整个方法的执行实际上是操作数栈和局部变量表之间不断load和store的过程</li></ul><h2 id="字节码工具"><a href="#字节码工具" class="headerlink" title="字节码工具"></a>字节码工具</h2><h3 id="ASM"><a href="#ASM" class="headerlink" title="ASM"></a>ASM</h3><p>对于需要手动操纵字节码的需求，可以使用ASM，它可以直接生产 .class字节码文件。以下是asm实现的架构：<br><img src="/assets/blogImg/asm.jpg" alt="asm"></p><p>使用工具<a href="https://plugins.jetbrains.com/plugin/5918-asm-bytecode-outline" target="_blank" rel="noopener">ASM ByteCode Outline</a>操作更简单</p><h3 id="Javassist"><a href="#Javassist" class="headerlink" title="Javassist"></a>Javassist</h3><p>ASM是在指令层次上操作字节码的，阅读上文后，我们的直观感受是在指令层次上操作字节码的框架实现起来比较晦涩。故除此之外，我们再简单介绍另外一类框架：强调源代码层次操作字节码的框架Javassist。<br>利用Javassist实现字节码增强时，可以无须关注字节码刻板的结构，其优点就在于编程简单。直接使用java编码的形式，而不需要了解虚拟机指令，就能动态改变类的结构或者动态生成类</p><h2 id="Java-Instrumentation-包"><a href="#Java-Instrumentation-包" class="headerlink" title="Java Instrumentation 包"></a>Java Instrumentation 包</h2><p>字节码修改工具如果只能在运行前修改，那么应用的范围其实不是很广。由于对字节码需求修改的需求巨大，jdk1.5引入了java.lang.instrument包，可以通过addTransformer增加一个ClassFileTransformer，通过ClassFileTransformer完成类的转换。<br>JDK1.5支持静态Instrumentation，具体实现是在jvm启动时候添加一个代理（javaagent)，这个代理是一个jar包，这个jar包MANIFEST.MF里指定了代理类，该代理类包含一个premain的方法，jvm在运行时先运行这个jar的premain方法，然后在执行具体的main方法，这种方式可以在class被加载前进行修改，无需对应用进行修改，就可以对类进行增强。大多数apm产品都是利用这种方式实现<br>JDK1.6就支持更强大的动态Instrumentation，在JVM 启动后通过 Attach API 远程加载代理包到应用上，这种称为agentmain。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4" target="_blank" rel="noopener">Oracle:The class File Format</a><br><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html" target="_blank" rel="noopener">Oracle:The Java Virtual Machine Instruction Set</a><br><a href="https://juejin.im/post/5d773ae1518825058772843c#heading-18" target="_blank" rel="noopener">Java字节码增强揭秘</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一次insert into on duplicate key upadte引发的问题</title>
      <link href="/2019/01/09/%E4%B8%80%E6%AC%A1insert%20into...on%20duplicate%20key%20upadte%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/01/09/%E4%B8%80%E6%AC%A1insert%20into...on%20duplicate%20key%20upadte%E5%BC%95%E5%8F%91%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>  最近有业务场景使用insert into … on duplicate key update进行插入更新操作，然后通过返回的affected rows来确定是进行了插入操作还是更新操作。印象中当不出现键冲突的时候affected rows应该为1（作用等同于insert into）, 而当键冲突的时候affected rows应该为2。但是实际情况是有键位冲突更新的时候affected rows返回的是1。  </p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>  首先我们梳理下表结构以及执行语句，业务表的设计大致如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="built_in">Record</span>(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">int</span> auto_increment primary <span class="keyword">key</span>,</span><br><span class="line">    user_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'用户id'</span>,</span><br><span class="line">    object_id <span class="built_in">int</span> <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">comment</span> <span class="string">'对方id'</span>,</span><br><span class="line">    create_time datetime <span class="keyword">not</span> <span class="literal">null</span> <span class="keyword">default</span> <span class="keyword">now</span>() <span class="keyword">comment</span> <span class="string">'记录创建时间'</span>,</span><br><span class="line">    <span class="keyword">unique</span> <span class="keyword">key</span> idx_user_object(<span class="string">`user_id`</span>,<span class="string">`object_id`</span>)</span><br><span class="line">)<span class="keyword">engine</span> = <span class="keyword">innodb</span> <span class="keyword">comment</span> <span class="string">'记录表'</span></span><br></pre></td></tr></table></figure><p>实际执行的业务操作语句如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="built_in">Record</span>(user_id,object_id,create_time) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="keyword">now</span>()) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> <span class="keyword">set</span> create_time = <span class="keyword">now</span>()</span><br></pre></td></tr></table></figure><p>查了<a href="https://dev.mysql.com/doc/refman/5.7/en/insert-on-duplicate.html" target="_blank" rel="noopener">MySQL Reference</a>可以发现是有对affected rows 进行说明的，内容如下:</p><blockquote><p>With ON DUPLICATE KEY UPDATE, the affected-rows value per row is 1 if the row is inserted as a new row, 2 if an existing row is updated, and 0 if an existing row is set to its current values. If you specify the CLIENT_FOUND_ROWS flag to the mysql_real_connect() C API function when connecting to mysqld, the affected-rows value is 1 (not 0) if an existing row is set to its current values.  </p></blockquote><p>也就是说当无主键冲突的时候affected row = 1；主键冲突的时候回去自定义更新记录 affected rows = 2；主键冲突但是自定义更新的值和原有值相同的时候affected rows = 0。如果mysql的参数CLIENT_FOUND_ROWS是设置成mysql_real_connect()，那么这种情况下也会返回1。那么问题很明显了，因为我们设置create_time是秒级别的，那么肯定存在一种情况，在你使用api连接mysql的时候加上参数CLIENT_FOUND_ROWS，在同一秒内A事务插入了一条记录返回affected rows = 1,B事务去执行更新的时候由于更新值和当前值相同导致返回affected rows = 1。</p><p>查询CLIENT_FOUND_ROWS发现如下解释：</p><blockquote><p>useAffectedRows<br>Don’t set the CLIENT_FOUND_ROWS flag when connecting to the server (not JDBC-compliant, will break most applications that rely on “found” rows vs. “affected rows” for DML statements), but does cause “correct” update counts from “INSERT … ON DUPLICATE KEY UPDATE” statements to be returned by the server.<br>Default: false<br>Since version: 5.1.7</p></blockquote><p>而默认jdbc是会默认传递CLIENT_FOUND_ROWS的，也就是返回的是寻找到的行，当然可以在连接参数上加上userAffectedRows=true来让其返回收影响的行</p><h2 id="问题验证"><a href="#问题验证" class="headerlink" title="问题验证"></a>问题验证</h2><p>直接在库中执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`Record`</span>(<span class="string">`user_id`</span>,<span class="string">`object_id`</span>,<span class="string">`create_time`</span>) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'2019-1-9 19:03:33'</span>) <span class="keyword">on</span> <span class="keyword">duplicate</span> <span class="keyword">key</span> <span class="keyword">update</span> create_time = <span class="string">'2019-1-9 19:03:33'</span></span><br></pre></td></tr></table></figure><p>返回<code>Query OK, 1 row affected</code>，接下来继续执行相同的语句，返回<code>Query OK, 0 rows affected</code>，意味着情况和文档描述的一样。我们通过jdbc直接操作会发现第二次执行语句时是会返回affected rows = 1的，在连接字符串上加上useAffectedRows是会发现返回的是affected rows = 0 </p><blockquote><p>注意<br>如果使用了mycat中间件的话，在连接字符串加useAffectedRow也没设么用，因为mycat默认配置的就是CLIENT_FOUND_ROWS<br><img src="/assets/blogImg/mycat-img01.jpg" alt="代码结构"><br></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker搭建mysql双主配置</title>
      <link href="/2018/05/10/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E5%8F%8C%E4%B8%BB%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/05/10/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E5%8F%8C%E4%B8%BB%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>互联网架构需要保证数据库高可用，常见的一种方式，使用双主同步+keepalived+虚ip的方式保证数据库的可用性。依照前文<a href="https://fibbery.me/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/" target="_blank" rel="noopener">使用docker搭建mysql简单主从集群</a> 想尝试一下使用docker搭建会有什么问题</p><a id="more"></a><h2 id="实践步骤"><a href="#实践步骤" class="headerlink" title="实践步骤"></a>实践步骤</h2><ol><li><p>搭建好docker网络<br> 因为需要两个容器互联，所以需要使用docker连创建互联网络，参见<a href="http://www.up4dev.com/2016/10/09/docker-network-create/" target="_blank" rel="noopener">用network create解决Docker容器互相连接的问题</a><br> </p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker network create my-net  # 先创建一个网络</span><br><span class="line">docker network ls # 查看一下是否创建成功</span><br></pre></td></tr></table></figure></li><li><p>新建masterA库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3306:3306 -v /data/mysqlcnf/masterA:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name masterA --net=my-net --net-alias=masterA mysql   # 利用自建网络搭建主库A</span><br></pre></td></tr></table></figure><p> 数据库配置文件如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server-id                = 1</span><br><span class="line">auto_increment_offset    = 1</span><br><span class="line">auto_increment_increment = 1</span><br><span class="line"></span><br><span class="line">log_bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">log-slave-updates      = true</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">lower_case_table_names = 1</span><br></pre></td></tr></table></figure><p> 因为是互为主从，所以auto_increment_offset(起始位移点)和auto_increment_increment(步长)必须间隔设置，同时必须开启log-slave-updates设置，前文有提到过。</p><p> 重启masterA库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart masterA</span><br></pre></td></tr></table></figure></li><li><p>新建masterB 主库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/masterB:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name masterB --net=my-net --net-alias=masterB mysql  # 利用自建网络搭建主库B</span><br></pre></td></tr></table></figure><p> 数据库配置文件如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id                = 2</span><br><span class="line">auto_increment_offset    = 2</span><br><span class="line">auto_increment_increment = 2</span><br><span class="line"></span><br><span class="line">log_bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">log-slave-updates      = true</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">lower_case_table_names = 1</span><br></pre></td></tr></table></figure><p> 重启B库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart masterB</span><br></pre></td></tr></table></figure></li><li><p>配置数据库帐号以及主从配置<br> 分别登录masterA和masterB添加从库同步帐号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'sync'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'sync'</span>  # 新建同步帐号</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span> # 刷新权限缓存</span><br></pre></td></tr></table></figure><p> 分别执行查看masterA和masterB的binlog情况</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure><p> 分别进行主从同步<br> ```sql</p><pre><code>change master to master_host=&apos;${host}&apos;,master_port=&apos;${port}&apos;,master_user= &apos;${master_user}&apos; ,master_password=&apos;${master_password}&apos;,master_log_file=&apos;${master_log_file}&apos;,master_log_pos=&apos;${master_log_pos}&apos;start slaveshow slave status\G</code></pre><p> ```　<br> 以上sql都可以观看前文得知，不再赘述。到此，双主mysql集群搭建完成。</p></li></ol><p></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用docker搭建mysql简单主从集群</title>
      <link href="/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/"/>
      <url>/2018/05/09/%E4%BD%BF%E7%94%A8docker%E6%90%AD%E5%BB%BAmysql%E7%AE%80%E5%8D%95%E4%B8%BB%E4%BB%8E%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近对mysql集群搭建以及后期如何在线上进行拆分和迁移产生了兴趣，所以初步想在自己本机通过docker搭建一个简单的主从集群来满足一下好奇心</p><a id="more"></a><h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><p>OS X EI Capitan 10.11.6<br>docker版本17.09.0-ce-mac35 (19611)<br>mysql镜像版本5.7(这里我直接下载的标签为latest的最新版本)</p><h2 id="具体实现步骤"><a href="#具体实现步骤" class="headerlink" title="具体实现步骤"></a>具体实现步骤</h2><h3 id="建立主库容器"><a href="#建立主库容器" class="headerlink" title="建立主库容器"></a>建立主库容器</h3><ol><li><p>建立主数据库</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/master:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name master mysql</span><br></pre></td></tr></table></figure></li><li><p>在本机目录/data/mysqlcnf/master中新建mysql数据库配置文件my.cnf，内容如下:</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id                = 1</span><br><span class="line">log_bin                  = mysql-bin</span><br><span class="line">binlog-format            = ROW</span><br><span class="line">lower_case_table_names   = 1</span><br></pre></td></tr></table></figure><p> 需要注意下mysql镜像自带是有配置文件的，我们映射过来的文件夹并不能完全覆盖，所以不要让配置文件冲突</p></li><li><p>重启容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart master</span><br></pre></td></tr></table></figure></li><li><p>建立授权帐号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">grant</span> <span class="keyword">replication</span> <span class="keyword">slave</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'sync'</span>@<span class="string">'%'</span> <span class="keyword">identified</span> <span class="keyword">by</span> <span class="string">'sync'</span></span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span></span><br></pre></td></tr></table></figure></li><li><p>查询下主库当前binlog情况</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span></span><br></pre></td></tr></table></figure><p> 记录下file和position，等到设置从库时需要</p></li></ol><h3 id="建立从库容器"><a href="#建立从库容器" class="headerlink" title="建立从库容器"></a>建立从库容器</h3><ol><li><p>建立从数据库(使用link实现从库连接主库)</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 3307:3306 -v /data/mysqlcnf/slave:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 --name slave --link master:master mysql</span><br></pre></td></tr></table></figure></li><li><p>从库配置文件</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id              = 2</span><br><span class="line"></span><br><span class="line">log-bin                = mysql-bin</span><br><span class="line">binlog-format          = ROW</span><br><span class="line">lower_case_table_names = 1</span><br><span class="line">log-slave-updates      = 1</span><br><span class="line">relay-log              = slave-relay-bin</span><br><span class="line">relay-log-index        = slave-relay-bin.index</span><br><span class="line">read-only              = 1</span><br></pre></td></tr></table></figure><p> log-slave-updates参数的意义在于，如果该库是从库，从主库binlog读取的更新是不会继续写入该库的binlog，设置该参数后则可以实现读取主库binlog之后写入自己库的binlog，用来做其他从库的主库</p></li><li><p>重启容器</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart slave</span><br></pre></td></tr></table></figure></li><li><p>登录从库服务器设置主库</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CHANGE</span> <span class="keyword">MASTER</span> <span class="keyword">TO</span> MASTER_HOST=<span class="string">'master'</span>,MASTER_USER=<span class="string">'sync'</span>, MASTER_PASSWORD=<span class="string">'sync'</span>,MASTER_LOG_FILE=<span class="string">'mysql-bin.000005'</span>, MASTER_LOG_POS=<span class="number">154</span>;</span><br><span class="line"><span class="keyword">flush</span> <span class="keyword">privileges</span></span><br><span class="line"><span class="keyword">start</span> <span class="keyword">slave</span></span><br></pre></td></tr></table></figure><p> 这里设置的值master_log_file以及master_log_pos根据当初查询主库得来</p></li><li><p>查看从库状态</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>\G</span><br></pre></td></tr></table></figure></li></ol><p>至此简单的mysql的主从集群搭建完成</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java序列化的一些了解</title>
      <link href="/2018/03/06/Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%86%E8%A7%A3/"/>
      <url>/2018/03/06/Java%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>通常来说序列化和反序列化通常是一起的。我们常见的就是你只要将类实现Serializable接口，就能将该类的对象序列化二进制文件，同时能通过反序列化将二进制文件还原成对象。<br><a id="more"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>我们通过Demo来了解Java序列化和反序列化的具体情况，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">7303637756547202487L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> staticVar = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//进行序列化到二进制文件中</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"out"</span>);</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        out.writeObject(<span class="keyword">new</span> Test());</span><br><span class="line">        out.close();</span><br><span class="line">        <span class="comment">//从二进制文件中反序列化成对象</span></span><br><span class="line">        ObjectInputStream ins = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        Test o = (Test) ins.readObject();</span><br><span class="line">        ins.close();</span><br><span class="line">        System.out.println(o.staticVar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>针对以上Demo可以知道Java的序列化和反序列化其实就是使用ObjectInputStream和ObjectInputStream对实现了Serializable类的读写。深入代码可以发现，在序列化过程中，虚拟机会试图调用对象类里的 writeObject 和 readObject 方法，进行用户自定义的序列化和反序列化，如果没有这样的方法，则默认调用是 ObjectOutputStream 的 defaultWriteObject 方法以及 ObjectInputStream 的 defaultReadObject 方法。</p><h2 id="序列化的特点"><a href="#序列化的特点" class="headerlink" title="序列化的特点"></a>序列化的特点</h2><ol><li>如果某个类可以被序列化，其子类也可以被序列化。但是如果子类实现序列化，父类没有，那么子类反序列化会将父类那部分属性丢失。</li><li>声明为static和transient类型的成员数据不能被序列化，因为static代表类的状态，而transient代表对象的临时数据。</li><li>Java 序列化机制为了节省磁盘空间，具有特定的存储规则，当写入文件的为同一对象时，并不会再将对象的内容进行存储，而只是再次存储一份引用。</li></ol><p>根据第三点使用Demo详细说明下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reference</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">8386243968193725155L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        Reference reference = <span class="keyword">new</span> Reference();</span><br><span class="line">        reference.setName(<span class="string">"java"</span>);</span><br><span class="line"></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"reference"</span>);</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(file));</span><br><span class="line">        os.writeObject(reference);</span><br><span class="line">        <span class="comment">//reference.setName("python")   ---- 展现特性的情况</span></span><br><span class="line">        os.writeObject(reference); <span class="comment">//再次写入</span></span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        Reference reference1 = (Reference) is.readObject();</span><br><span class="line">        Reference reference2 = (Reference) is.readObject();</span><br><span class="line">        System.out.println(reference1 == reference2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果是true，同时比较写入一个对象的文件大小和写入两次相同对象文件的大小，发现没有呈2倍关系，证明其实第二次写入的只是一个引用而已。同时我们释放Demo的特性情况注释，发现结果还是True，说明在写入第一个对象之后，虽然改变了对象的成员变量，但是成员地址没有发生改变，虚拟机在进行第二次写入的时候，发现了一个相同的对象(地址相同)已经写入文件，因此只保存了一个引用，所以读取时，返回的仍然是第一次的对象。</p><blockquote><p>使用一个文件多次writeObject的时候需要注意这个问题</p></blockquote><h2 id="一些序列化的特性以及对应场景"><a href="#一些序列化的特性以及对应场景" class="headerlink" title="一些序列化的特性以及对应场景"></a>一些序列化的特性以及对应场景</h2><h3 id="序列化ID的作用"><a href="#序列化ID的作用" class="headerlink" title="序列化ID的作用"></a>序列化ID的作用</h3><h4 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h4><p>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常。当实现java.io.Serializable接口的实体（类）没有显式地定义一个名为serialVersionUID，类型为long的变量时，Java序列化机制会根据编译的class自动生成一个serialVersionUID作序列化版本比较用，这种情况下，只有同一次编译生成的class才会生成相同的serialVersionUID。因此为了实现序列化接口的实体能够兼容先前版本，最好显式地定义一个名为serialVersionUID类型为long的变量，这样就不会存在版本不一致的问题。<br>序列化 ID 在 Eclipse 下提供了两种生成策略，一个是固定的 1L，一个是随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成），在这里有一个建议，如果没有特殊需求，就是用默认的 1L 就可以，这样可以确保代码一致时反序列化成功。那么随机生成的序列化 ID 有什么作用呢，有些时候，通过改变序列化 ID 可以用来限制某些用户的使用。</p><h4 id="应对场景"><a href="#应对场景" class="headerlink" title="应对场景"></a>应对场景</h4><p>Java中RMI(Remoting Method Inovke)的实现</p><h3 id="父类序列化和Transient关键字"><a href="#父类序列化和Transient关键字" class="headerlink" title="父类序列化和Transient关键字"></a>父类序列化和Transient关键字</h3><h4 id="由来-1"><a href="#由来-1" class="headerlink" title="由来"></a>由来</h4><blockquote><p>参见<a href="#序列化的特点">序列化特点</a></p></blockquote><h4 id="应对场景-1"><a href="#应对场景-1" class="headerlink" title="应对场景"></a>应对场景</h4><p>平常我们都是使用transient关键字使字段不被序列化，但是如果有过多相同的类有同样的字段不需要序列化，我们可以将这些成员变量抽出来做成虚基类，根据父类对象序列化的规则，只要父类不实现Serializable接口，这写成员变量都不会被序列化。</p><h3 id="敏感字段加密"><a href="#敏感字段加密" class="headerlink" title="敏感字段加密"></a>敏感字段加密</h3><h4 id="由来-2"><a href="#由来-2" class="headerlink" title="由来"></a>由来</h4><blockquote><p>参见<a href="#具体实现">具体实现</a></p></blockquote><h4 id="应对场景-2"><a href="#应对场景-2" class="headerlink" title="应对场景"></a>应对场景</h4><p>一些敏感信息不便于传输，可以对敏感字段进行加密，只有正确的客户端和服务端能加密和解密，避免传输过程中泄漏。因此可以在对象里自定义writeObject 和 readObject 方法，这样就可以完全控制对象序列化的过程，从而可以在序列化的过程中对某些数据进行加解密操作。<br>Demo代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5790119844861945929L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"pass"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream os)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectOutputStream.PutField field = os.putFields();</span><br><span class="line">            System.out.println(<span class="string">" 原始密码: "</span> + password);</span><br><span class="line">            String encryptedPass = encrypt(password);<span class="comment">//伪码模拟加密</span></span><br><span class="line">            field.put(<span class="string">"password"</span>, encryptedPass); </span><br><span class="line">            os.writeFields();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream is)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ObjectInputStream.GetField field = is.readFields();</span><br><span class="line">            Object encryptPass = field.get(<span class="string">"password"</span>, <span class="string">""</span>);</span><br><span class="line">            System.out.println(<span class="string">"获取加密的字符串："</span> + encryptPass);</span><br><span class="line">            String decryptPass = decryptPass(encryptPass); <span class="comment">//伪码模拟解密</span></span><br><span class="line">            password = decryptPass; </span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"password"</span>)));</span><br><span class="line">        os.writeObject(<span class="keyword">new</span> Account());</span><br><span class="line">        os.close();</span><br><span class="line"></span><br><span class="line">        ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"password"</span>)));</span><br><span class="line">        Account o = (Account) is.readObject();</span><br><span class="line">        System.out.println(<span class="string">"解密后的密码是："</span> + o.password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>1.<a href="http://blog.csdn.net/jiangwei0910410003/article/details/18989711" target="_blank" rel="noopener">Java中的序列化Serialable高级详解</a><br>2.<a href="http://www.oschina.net/question/4873_23270" target="_blank" rel="noopener">Java序列化的作用</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> serializable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo通信实现</title>
      <link href="/2018/03/03/Dubbo%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/03/03/Dubbo%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>基于dubbo默认通讯服务器Netty来解析服务端和客户端如何通讯<br><a id="more"></a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="暴露服务"><a href="#暴露服务" class="headerlink" title="暴露服务"></a>暴露服务</h3><p>首先我们看下协议接口类Protocol中暴露服务的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 暴露远程调用服务：</span></span><br><span class="line"><span class="comment"> * 1. 该通信协议必须在接到请求之后记录请求的源地址：</span></span><br><span class="line"><span class="comment"> *RpcContext.getContext().setRemoteAddress()</span></span><br><span class="line"><span class="comment"> * 2. export必须是幂等的。意味着使用相同的URL不论是调用一次还是调用两次，结果都是一样的</span></span><br><span class="line"><span class="comment"> * 3. invoker实例是由框架实现的，跟协议没任何关系</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> T 服务的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> invoker 服务实现的实例</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回被暴露服务实例的引用，用于取消服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Exporter&lt;T&gt; <span class="title">export</span><span class="params">(Invoker&lt;T&gt; invoker)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p>然后我们看分析dubbo协议的暴露服务的具体实现DubboProtocol.export的过程如下</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">export</span> ---&gt;</span> <span class="function"><span class="title">openServer</span> ---&gt;</span> <span class="function"><span class="title">createServer</span> ---&gt;</span>  Exchangers.bind(url,handler)</span><br></pre></td></tr></table></figure><p>openServer根据invoker携带的URL信息获取host以及ip，如果已经存在，则不会创建服务。<br>然后我们继续看下<em>Exchanger</em>的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (url == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"url == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"handler == null"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       url = url.addParameterIfAbsent(Constants.CODEC_KEY, <span class="string">"exchange"</span>);</span><br><span class="line">       <span class="keyword">return</span> getExchanger(url).bind(url, handler);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><em>getExchanger(url)</em>典型的策略模式，得到HeaderExchanger，代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ExchangeServer <span class="title">bind</span><span class="params">(URL url, ExchangeHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> HeaderExchangeServer(Transporters.bind(url, <span class="keyword">new</span> DecodeHandler(<span class="keyword">new</span> HeaderExchangeHandler(handler))));</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ol><li><em>HeaderExchangeServer</em>其实是真正server的包裹类，提供了server的一些操作接口已经对server的一个心跳检测功能。</li><li>Transporters.bind这一步就是根据url选择对应的通信框架开启服务(此例中采用NettyTransport)。</li><li>new DecodeHandler(new HeaderExchangeHandler(handler)))采用装饰器模式构造服务端通道的handler</li></ol><blockquote><p>此处不讨论DecodeHandler如何对该协议通道的信息decode以及encode的过程</p></blockquote><h3 id="引用服务"><a href="#引用服务" class="headerlink" title="引用服务"></a>引用服务</h3><p>我们看下Protocol中引用服务的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 引用远程服务</span></span><br><span class="line"><span class="comment">     * 1.当使用者调用invoker(通信协议使用refer方法生成)的invoke方法的时候，通信协议</span></span><br><span class="line"><span class="comment">     * 会相应的让服务端对应的invoker调用invoke方法。</span></span><br><span class="line"><span class="comment">     * 2.refer返回的invoker实例是由通信协议生成实现的。实现的过程只不过是将方法调用的过程</span></span><br><span class="line"><span class="comment">     * 封装成用远程请求的方式。</span></span><br><span class="line"><span class="comment">     * 3.当URL设置check=false的时候，客户端不应该在连接服务端失败的时候抛出异常，并且有</span></span><br><span class="line"><span class="comment">     * 义务尝试重连</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;T&gt; 远程服务的类型</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> type 远程服务类的class</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url 远程服务的url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> invoker 远程服务的本地代理实现</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Adaptive</span></span><br><span class="line">&lt;T&gt; <span class="function">Invoker&lt;T&gt; <span class="title">refer</span><span class="params">(Class&lt;T&gt; type, URL url)</span> <span class="keyword">throws</span> RpcException</span>;</span><br></pre></td></tr></table></figure><p>我们还是通过DubboProtocol来看客户端如何实现远程调用，refer方法在初始的时候会初始化一个与对应远端的连接，同时返回持有这个连接的对象invoker。我们需要将其转换成对应需要使用的服务类，在这里就需要用到动态代理这样的一个方式来生成一个本地句柄，以便客户端像调用本地服务一样调用。所以，一般客户端使用如下(伪码)：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ProxyFactory proxyFactory = ExtensionLoader.getExtensionLoader(ProxyFactory.class).getAdaptiveExtension();</span><br><span class="line">DemoService service = proxyFactory.getProxy(refer(type,url)); <span class="comment">//本地生成代理类</span></span><br><span class="line">service.echo(); <span class="comment">//调用方法</span></span><br></pre></td></tr></table></figure><p>接下来我们具体看JavassistProxyFactory是怎么生成一个客户端需要的代理类的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getProxy</span><span class="params">(Invoker&lt;T&gt; invoker, Class&lt;?&gt;[] interfaces)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (T) Proxy.getProxy(interfaces).newInstance(<span class="keyword">new</span> InvokerInvocationHandler(invoker));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>InvokerInvocationHandler这个类是很明显的装饰器模式，让属于Object类中的方法以及toString、hashCode、equals一些通用方法只在本地调用，实际上我们还是使用的DubboInvoker的invoker方法，也就是其中具体的doInvoke方法。代码点实现也只是使用返回的invoker对象中持有的客户端连接来发送请求消息，获取返回结果。</p><blockquote><p>dubbo暴露方法和对远程方法的调用可以阅读源码DubboProtocolTest.testDemoProtocol来了解</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dubbo - netty - java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL生成根证书CA</title>
      <link href="/2018/02/06/OpenSSL%E7%94%9F%E6%88%90%E6%A0%B9%E8%AF%81%E4%B9%A6CA/"/>
      <url>/2018/02/06/OpenSSL%E7%94%9F%E6%88%90%E6%A0%B9%E8%AF%81%E4%B9%A6CA/</url>
      
        <content type="html"><![CDATA[<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><p>本机Mac，所以只讨论Mac环境下的生成方法。<br>需要安装openssl，如果没有可以使用homebrew安装。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install openssl</span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><blockquote><p>以下所有[]中的内容代表可选项目</p></blockquote><h3 id="生成根证书CA"><a href="#生成根证书CA" class="headerlink" title="生成根证书CA"></a>生成根证书CA</h3><h4 id="1-生成根证书私钥"><a href="#1-生成根证书私钥" class="headerlink" title="1)生成根证书私钥"></a>1)生成根证书私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa [-aes256] -out ca_private.pem 2048</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>genrsa 表示使用rsa算法产生私钥</li><li>2048 表示私钥长度</li><li>-aes256表示使用256位的AES算法对密钥进行加密，另外还有des3</li></ul><h4 id="2-生成根证书请求文件"><a href="#2-生成根证书请求文件" class="headerlink" title="2)生成根证书请求文件"></a>2)生成根证书请求文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key ca_private.pem -out ca.csr -subj "/C=CN/ST=Guangdong/L=Shenzhen/O=Zhenai/OU=Java/CN=HttpProxy"</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>req 表示执行证书签发命令</li><li>new 表示新证书签发请求</li><li>key 指定证书私钥路径</li><li>out表示输出的证书请求文件的位置</li><li>subj表示证书相关的用户信息</li></ul><h4 id="3-自签发根证书"><a href="#3-自签发根证书" class="headerlink" title="3)自签发根证书"></a>3)自签发根证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 [-sha1] [-extfile openssl.cnf] [-extensions v3_ca] -signkey ca_private.pem -in ca.csr -out ca.crt</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>x509表示生成x509格式证书</li><li>req 表示输入csr文件</li><li>days 表示证书有效期(天)</li><li>sha1表示证书的摘要使用sha1</li><li>extensions 表示安装openssl.conf文件中配置的v3_ca项添加拓展</li><li>extfile 表示配置文件，下方有提供。</li><li>signkey 表示签发证书使用的私钥</li></ul><h3 id="用根证书签发server端证书"><a href="#用根证书签发server端证书" class="headerlink" title="用根证书签发server端证书"></a>用根证书签发server端证书</h3><h4 id="1-生成服务端私钥"><a href="#1-生成服务端私钥" class="headerlink" title="1)生成服务端私钥"></a>1)生成服务端私钥</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out server_private.pem 2048</span><br></pre></td></tr></table></figure><h4 id="2-生成证书请求文件"><a href="#2-生成证书请求文件" class="headerlink" title="2)生成证书请求文件"></a>2)生成证书请求文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key server_private.pem -out server.csr -subj "/C=CN/ST=Guangdong/L=Shenzhen/O=Zhenai/OU=Java/CN=HttpProxy"</span><br></pre></td></tr></table></figure><h4 id="3-利用根证书签发服务端证书"><a href="#3-利用根证书签发服务端证书" class="headerlink" title="3)利用根证书签发服务端证书"></a>3)利用根证书签发服务端证书</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -req -days 365 [-sha256] [-extfile openssl.conf] [-extensions v3_req] -CA ca.crt -CAkey ca_private.pem -CAserial ca.srl -CAcreateserial -in server.csr -out server.crt</span><br></pre></td></tr></table></figure><p>含义：</p><ul><li>CA 指定ca证书</li><li>CAkey指定证书的私钥</li><li>CAserial 指定证书序列号文件</li><li>表示创建证书序列号文件(即上方提到的serial文件)，创建的序列号文件默认名称为-CA，指定的证书名称后加上.srl后缀。<blockquote><p>注意这里的是<strong>-extensions v3_req</strong> </p></blockquote></li></ul><h2 id="注意要点"><a href="#注意要点" class="headerlink" title="注意要点"></a>注意要点</h2><ol><li><p>上面过程中生成的私钥是不能直接被java读取的，只能通过下述命令转换一下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl pkcs8 -topk8 -nocrypt -inform PEM -outform PEM -in ca_private.pem  -out ca_private_pkcs8.pem</span><br></pre></td></tr></table></figure></li><li><p>curl使用证书的时候必须是pem格式的，crt到pem格式转换如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in ca.crt -out ca.pem -text</span><br></pre></td></tr></table></figure></li></ol><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ol><li>openssl.conf文件下载：<a href="/assets/file/openssl.conf">下载文件</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openssl </tag>
            
            <tag> https </tag>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java读取openssl创建的公私钥</title>
      <link href="/2018/01/19/java%E8%AF%BB%E5%8F%96openssl%E5%88%9B%E5%BB%BA%E7%9A%84%E5%85%AC%E7%A7%81%E9%92%A5/"/>
      <url>/2018/01/19/java%E8%AF%BB%E5%8F%96openssl%E5%88%9B%E5%BB%BA%E7%9A%84%E5%85%AC%E7%A7%81%E9%92%A5/</url>
      
        <content type="html"><![CDATA[<p>最近在考虑使用Netty搭建HTTP/HTTPS代理服务器，遇到了openssl密钥读取问题，下面概述步骤。<br>选用openssl生成密钥的初衷是netty的SslContextBuilder对其支持比较直接，相较于使用keytool更为容易读取。</p><a id="more"></a><h2 id="公私钥以及证书的生成"><a href="#公私钥以及证书的生成" class="headerlink" title="公私钥以及证书的生成"></a>公私钥以及证书的生成</h2><p>openssl工具生成十分简单，只概叙其命令步骤<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成私钥</span></span><br><span class="line">1. openssl genrsa -out rsa_private_key.pem 1024</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据私钥生成公钥</span></span><br><span class="line">2. openssl rsa -in rsa_private_key.pem -out rsa_public_key.pem -outform PEM -pubout  </span><br><span class="line"><span class="meta">#</span><span class="bash"> java不能直接读取该私钥，需要转换成pkcs8格式</span></span><br><span class="line">3. openssl pkcs8 -topk8 -inform PEM -in rsa_private_key.pem -outform PEM -nocrypt -out rsa_private_key_pkcs8.pem</span><br><span class="line"><span class="meta">#</span><span class="bash"> 根据私钥创建证书请求</span></span><br><span class="line">4. openssl req -new -key rsa_private_key.pem -out rsa_public_key.csr</span><br><span class="line"><span class="meta">#</span><span class="bash"> 生成证书并且签名</span></span><br><span class="line">5. openssl x509 -req -days 3650 -in rsa_public_key.csr -signkey rsa_private_key.pem -out rsa_public_key.crt</span><br></pre></td></tr></table></figure></p><h3 id="java读取私钥以及公钥"><a href="#java读取私钥以及公钥" class="headerlink" title="java读取私钥以及公钥"></a>java读取私钥以及公钥</h3><p>文本打开公私钥，可以发现格式都是如下类似格式：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">----<span class="keyword">BEGIN</span> PUBLIC KEY-----</span></span><br><span class="line"><span class="ruby">MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQC5M2njgC84dLEvMHNHEmZMhtYx</span></span><br><span class="line"><span class="ruby">w7ncLjZQIyAHyGfruJqTksdJ16V1eRNN3pEn17QAOk6Y3pPjyH/+Meir2iK9GGyB</span></span><br><span class="line"><span class="ruby">L9Yvli0eo5xMcLv1XmLeLgQ1EFetRj6i4jTtvaIAIb0uAG3XHHqmQRD6+nLnqV5E</span></span><br><span class="line"><span class="ruby">f3iHyXNfo12Y7bjbbwIDAQAB</span></span><br><span class="line"><span class="ruby">-----<span class="keyword">END</span> PUBLIC KEY-----</span></span><br></pre></td></tr></table></figure></p><p>可以看出导出的文本都是Base64编码的字符串，我们只需要读入有效字符串，然后实例化成具体实体即可。</p><ol><li><p>读取文本字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">readKeyStr</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(in));</span><br><span class="line">        StringBuilder buffer = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        String line = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (line.charAt(<span class="number">0</span>) != <span class="string">'-'</span>) &#123;</span><br><span class="line">                buffer.append(line);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> buffer.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>base64解码成真正的密钥字符</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br></pre></td></tr></table></figure></li><li><p>实例化成具体密钥实体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RSAPublicKey <span class="title">loadPublicKey</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"rsa"</span>);</span><br><span class="line">        X509EncodedKeySpec spec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        <span class="keyword">return</span> (RSAPublicKey) factory.generatePublic(spec);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RSAPrivateKey <span class="title">loadPrivateKey</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(readKeyStr(in));</span><br><span class="line">        KeyFactory factory = KeyFactory.getInstance(<span class="string">"rsa"</span>);</span><br><span class="line">        PKCS8EncodedKeySpec spec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        <span class="keyword">return</span> (RSAPrivateKey) factory.generatePrivate(spec);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> openssl </tag>
            
            <tag> rsa </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dubbo中SPI拓展机制的实现</title>
      <link href="/2018/01/15/Dubbo%E4%B8%ADSPI%E6%8B%93%E5%B1%95%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/01/15/Dubbo%E4%B8%ADSPI%E6%8B%93%E5%B1%95%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>初步说明下java原生的spi拓展加载机制：</p><blockquote><p>扫描META-INF/services下面的所有文件，文件都是使用接口或者抽象类名字作为文件名，具体实现类作为文件内容构成，在使用的时候只能通过遍历来实现查找和实例化，有可能会一次性把所有的实现都实例化，造成不必要的浪费。</p></blockquote><a id="more"></a><p>dubbo在原有的基础上拓展了以下几点：</p><ol><li>根据需要实例化拓展点。</li><li>自动注入需要依赖的拓展点，换而言之，就是增加了拓展点IoC和AOP的支持，一个拓展点能注入其他拓展点。<br>同时，dubbo读取文件方式也增加了，放置扩展点配置文件夹在原来的基础上增加了 <code>META-INF/dubbo/接口全限定名</code>以及<code>META-INF/dubbo/internal/接口全限定名</code>，内容为：<code>配置名=扩展实现类全限定名</code>，多个实现类用换行符分隔。<br>dubbo拓展点都是依赖ExtensionLoader的getExtension方法加载的，其中ExtensionLoader的type表明需要加载的的类的所属类型。其中getExtension的初次获取流程如下：<br><img src="/assets/blogImg/Dubbo-ExtensonLoader获取拓展点实现流程.png" alt="Dubbo-ExtensonLoader获取拓展点实现流程"></li></ol><p>通过上图流程可以分析出拓展点的以下属性</p><h3 id="拓展点自动包装"><a href="#拓展点自动包装" class="headerlink" title="拓展点自动包装"></a>拓展点自动包装</h3><p>自动包装拓展的wrapper类也是拓展点的实现类，ExtensionLoader在加载拓展点的时候，会将拥有该类型的构造函数的拓展点当做wrapper类。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码点ExtensionLoader.loadFile()</span></span><br><span class="line">clazz.getConstructor(type);</span><br><span class="line">Set&lt;Class&lt;?&gt;&gt; wrappers = cacheWrapperClasses;</span><br><span class="line"><span class="keyword">if</span>(wrappers == <span class="keyword">null</span>)&#123;</span><br><span class="line">  cacheWrapperClasses = <span class="keyword">new</span> ConcurrentHashSet&lt;Class&lt;?&gt;&gt;();</span><br><span class="line">  wrappers = cacheWrapperClasses;</span><br><span class="line">&#125;</span><br><span class="line">wrappers.add(clazz);</span><br></pre></td></tr></table></figure></p><p>当使用ExtensionLoader返回拓展点时，返回的其实是wrapper类的实例，该实例持有实际的拓展点实现。<br>这种拓展类可以有很多个，可以根据实际需要新增。<br>所以可以把所有拓展点的公共逻辑都置于wrapper类中，类似于aop，wrapper代理了实际需要的拓展点。</p><h3 id="拓展点自适应"><a href="#拓展点自适应" class="headerlink" title="拓展点自适应"></a>拓展点自适应</h3><p>很多时候拓展点是有多个实现的，我们需要给定一个参数来让使用者决定使用哪个拓展点，在dubbo中我们是使用com.alibaba.dubbo.common.URL来传递这样一个信息。因此，ExtensionLoader会有一个唯一的AdptiveClass(适配类)，然后通过URL这样一个变量容器来决定使用哪个具体的拓展点实现。当然，如果一个拓展点只有一个实现类，是不需要AdptiveClass的。获取适配类的方法为getAdaptiveExtension流程如下：<br><img src="/assets/blogImg/Dubbo的ExtensionLoader获取适配类流程.png" alt="Dubbo的ExtensionLoader获取适配类流程"><br>所以，要让拓展点支持自适应，需要满足以下条件：</p><ol><li>拓展点实现类有@Adaptive注解</li><li>拓展点接口方法有@Adaptive注解并且对应接口方法参数是com.alibaba.dubbo.common.URL或者包含com.alibaba.dubbo.common.URL属性<br>使用适配类依赖注入的demo如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SPI</span>(<span class="string">"impl1"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SimpleExt</span> </span>&#123;</span><br><span class="line">    <span class="comment">// @Adaptive example, do not specify a explicit key.</span></span><br><span class="line">    <span class="meta">@Adaptive</span></span><br><span class="line">    <span class="function">String <span class="title">echo</span><span class="params">(URL url, String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Adaptive</span>(&#123;<span class="string">"key1"</span>, <span class="string">"key2"</span>&#125;)</span><br><span class="line">    <span class="function">String <span class="title">yell</span><span class="params">(URL url, String s)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// no @Adaptive</span></span><br><span class="line">    <span class="function">String <span class="title">bang</span><span class="params">(URL url, <span class="keyword">int</span> i)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExtImpl1</span> <span class="keyword">implements</span> <span class="title">SimpleExt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(URL url, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ext1Impl1-echo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">yell</span><span class="params">(URL url, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ext1Impl1-yell"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bang</span><span class="params">(URL url, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bang1"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleExtImpl2</span> <span class="keyword">implements</span> <span class="title">SimpleExt</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">echo</span><span class="params">(URL url, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ext1Impl2-echo"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">yell</span><span class="params">(URL url, String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Ext1Impl2-yell"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">bang</span><span class="params">(URL url, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"bang2"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试demo如下</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test_getAdaptiveExtension_defaultAdaptiveKey</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            SimpleExt ext = ExtensionLoader.getExtensionLoader(SimpleExt.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">            Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, <span class="number">1010</span>, <span class="string">"path1"</span>, map);</span><br><span class="line"></span><br><span class="line">            String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">            assertEquals(<span class="string">"Ext1Impl1-echo"</span>, echo);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            SimpleExt ext = ExtensionLoader.getExtensionLoader(SimpleExt.class).getAdaptiveExtension();</span><br><span class="line"></span><br><span class="line">            Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            map.put(<span class="string">"simple.ext"</span>, <span class="string">"impl2"</span>);</span><br><span class="line">            URL url = <span class="keyword">new</span> URL(<span class="string">"p1"</span>, <span class="string">"1.2.3.4"</span>, <span class="number">1010</span>, <span class="string">"path1"</span>, map);</span><br><span class="line"></span><br><span class="line">            String echo = ext.echo(url, <span class="string">"haha"</span>);</span><br><span class="line">            assertEquals(<span class="string">"Ext1Impl2-echo"</span>, echo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>关于拓展点再com.alibaba.dubbo.common.URL中的参数名字确定是由本身类名决定的，带入如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ExtensionLoader.createAdaptiveExtensionClassCode()**/</span></span><br><span class="line"><span class="comment">// value is not set, use the value generated from class name as the key</span></span><br><span class="line"><span class="keyword">if</span> (value.length == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>[] charArray = type.getSimpleName().toCharArray();</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">128</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Character.isUpperCase(charArray[i])) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            sb.append(<span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(Character.toLowerCase(charArray[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sb.append(charArray[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    value = <span class="keyword">new</span> String[]&#123;sb.toString()&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>例如SimpleExt接口，适配类会根据com.alibaba.dubbo.common.URL中参数simple.ext的值来获取对应拓展点，同时意味着注入的拓展点可以根据URL参数不同而变化。</p><h3 id="扩展点自动注入"><a href="#扩展点自动注入" class="headerlink" title="扩展点自动注入"></a>扩展点自动注入</h3><p>injectExtension代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ExtensionLoader.injectExtension</span></span><br><span class="line"><span class="keyword">if</span>(objectFactory != <span class="keyword">null</span>)&#123;</span><br><span class="line">  <span class="comment">/*判断实例中是否有set方法，该set方法满足只有一个参数并且是public的*/</span></span><br><span class="line">  <span class="keyword">for</span>(Method method: instance.getClass().getMethods())&#123;</span><br><span class="line">    <span class="keyword">if</span>(method.getName().startWith(<span class="string">"set"</span>) &amp;&amp; method.getParameterTypes().length == <span class="number">1</span></span><br><span class="line">       &amp;&amp; Modifier.isPublic(method.getModifier()))&#123;</span><br><span class="line">      Class&lt;?&gt; pt = method.getParameterTypes()[<span class="number">0</span>]; <span class="comment">//获取set方法的参数类型</span></span><br><span class="line">      String property = method.getName().length() &gt; <span class="number">3</span> method.getName().substring(<span class="number">3</span>,<span class="number">4</span>).toLowerCase() + method.getName().subtring(<span class="number">4</span>) : <span class="string">""</span>; <span class="comment">//获取该set方法的属性名字</span></span><br><span class="line">      Object object = objectFactory.getExtension(pt,property); <span class="comment">//获取对应pt类型的adaptive类来注入</span></span><br><span class="line">      <span class="keyword">if</span>(object != <span class="keyword">null</span>)&#123;</span><br><span class="line">        method.invoke(instance,object);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码可以知道，往拓展点注入其他的拓展点需要满足以下几点：</p><ol><li>该拓展点有set其他拓展点的方法</li><li>如果是spi注入方式的拓展，那么注入的拓展点类必须满足拓展点自适应的要求，那么可以保证注入的拓展点其实是此类拓展点的Adaptive实例。(这一点主要跟注入的拓展点的拓展方式有关，目前已知的就SpiExtensionFactory和SpringExtensionFactory，意味着除了能注入spi拓展还能注入spring容器中的对象)  </li></ol><p>对于第二点，我们可以深挖代码来解答，代码顺序如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ExtensionLoader.injectExtension**/</span></span><br><span class="line">Object object = objectFactory.getExtension(pt,property);</span><br><span class="line">||</span><br><span class="line"><span class="comment">/** AdaptiveExtensionFactory.getExtension **/</span></span><br><span class="line">T extension = factory.getExtension(type,name)</span><br><span class="line">||</span><br><span class="line">SpringExtensionFactory.getExtension()/SpiExtensionFactory</span><br></pre></td></tr></table></figure></p><h3 id="拓展点自动激活"><a href="#拓展点自动激活" class="headerlink" title="拓展点自动激活"></a>拓展点自动激活</h3><p>这个特性是为了简化配置产生的，因为少数情况下需要获取到一些集合实现类实现链式操作，例如Filter。此时使用@Activate注解就能直接从cachedActivates获取对应class(cachedActivates在ExtensionLoader初始化的时候已经加载好，用拓展点实现的name作为key，用@Activate注解的内容作为value存储)。具体代码demo可以参考dubbo的ProtocolFilterWrapper.buildInvokerChain。Activate主要配合<em>ExtensionLoader.getActivateExtension(URL url, String key, String group)</em>使用，其中各个字段的释义分别如下</p><ul><li>group : 当组名适配的时候激活当前的拓展类</li><li>value： 如果当前组名适配并且URL中有当前参数才能激活此拓展类</li><li>order：绝对顺序 </li><li>before：相对顺序(在某个拓展之前)</li><li>after：相对顺序(在某个拓展之后)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> dubbo </tag>
            
            <tag> spi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分析java线程池实现原理</title>
      <link href="/2018/01/09/%E5%88%86%E6%9E%90java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
      <url>/2018/01/09/%E5%88%86%E6%9E%90java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>线程是稀缺资源，如果无限制创建会消耗大量系统资源，同时也不利于管理。线程池的出现就是为了解决这类问题。</p><a id="more"></a><h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><h3 id="构造参数解析"><a href="#构造参数解析" class="headerlink" title="构造参数解析"></a>构造参数解析</h3><p>通常我们使用Executors这个工厂类来快速初始化一个符合要求的线程池，其实本质都是通过不同的参数实例化ThreadPoolExecutor，下面我们通过jdk文档来了解各个参数的意思，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Creates a new &#123;<span class="doctag">@code</span> ThreadPoolExecutor&#125; with the given initial</span></span><br><span class="line"><span class="comment">    * parameters.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span></span><br><span class="line"><span class="comment">    *        if they are idle, unless &#123;<span class="doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span></span><br><span class="line"><span class="comment">    *        pool</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> keepAliveTime when the number of threads is greater than</span></span><br><span class="line"><span class="comment">    *        the core, this is the maximum time that excess idle threads</span></span><br><span class="line"><span class="comment">    *        will wait for new tasks before terminating.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> unit the time unit for the &#123;<span class="doctag">@code</span> keepAliveTime&#125; argument</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> workQueue the queue to use for holding tasks before they are</span></span><br><span class="line"><span class="comment">    *        executed.  This queue will hold only the &#123;<span class="doctag">@code</span> Runnable&#125;</span></span><br><span class="line"><span class="comment">    *        tasks submitted by the &#123;<span class="doctag">@code</span> execute&#125; method.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> threadFactory the factory to use when the executor</span></span><br><span class="line"><span class="comment">    *        creates a new thread</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> handler the handler to use when execution is blocked</span></span><br><span class="line"><span class="comment">    *        because the thread bounds and queue capacities are reached</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IllegalArgumentException if one of the following holds:&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> corePoolSize &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> keepAliveTime &lt; 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt;= 0&#125;&lt;br&gt;</span></span><br><span class="line"><span class="comment">    *         &#123;<span class="doctag">@code</span> maximumPoolSize &lt; corePoolSize&#125;</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> NullPointerException if &#123;<span class="doctag">@code</span> workQueue&#125;</span></span><br><span class="line"><span class="comment">    *         or &#123;<span class="doctag">@code</span> threadFactory&#125; or &#123;<span class="doctag">@code</span> handler&#125; is null</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                             TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                             BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                             ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                             RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">           maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">           keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">       <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">               <span class="keyword">null</span> :</span><br><span class="line">               AccessController.getContext();</span><br><span class="line">       <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">       <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">       <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">       <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">       <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="corePoolSize"><a href="#corePoolSize" class="headerlink" title="corePoolSize"></a>corePoolSize</h4><p>核心线程数，如果线程池中创建了核心线程，那么他们会一直存活(即使空闲)。如果你将allowCoreThreadTimeOut设置为true的话，那么空闲的核心线程才会被终止。如果你执行了prestartAllCoreThreads()，会提前启动所有核心线程。</p><h4 id="maximumPoolSize"><a href="#maximumPoolSize" class="headerlink" title="maximumPoolSize"></a>maximumPoolSize</h4><p>线程池中能持有的最大线程数</p><h4 id="keepAliveTime"><a href="#keepAliveTime" class="headerlink" title="keepAliveTime"></a>keepAliveTime</h4><p>超过核心线程数的那部分线程最大空闲时间</p><h4 id="unit"><a href="#unit" class="headerlink" title="unit"></a>unit</h4><p>keepAliveTime的时间单位</p><h4 id="workQueue"><a href="#workQueue" class="headerlink" title="workQueue"></a>workQueue</h4><p>保存用户被执行任务的队列，现有的几种阻塞队列如下：</p><ol><li>ArrayBlockingQueue</li><li>LinkedBlockingQueue</li><li>SynchronousQuene</li><li>PriorityBlockingQueue</li></ol><h4 id="threadFactory"><a href="#threadFactory" class="headerlink" title="threadFactory"></a>threadFactory</h4><p>创建线程的工厂类</p><h4 id="handler"><a href="#handler" class="headerlink" title="handler"></a>handler</h4><p>当线程执行阻塞或者容量已经到达限度时，需要执行的策略处理方式。现有的处理方式如下：</p><ol><li>AbortPolicy：直接抛出异常(默认策略)</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务</li><li>DiscardOldestPolicy：去掉队列中最老的任务，再次调用ThreadPoolExecutor.execute执行该任务</li><li>DiscardPolicy：直接抛弃该任务，不做任何操作</li></ol><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>提交我们需要执行的任务通常使用ThreadPoolExecutor.execute(Runnable r)，源码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上述ctl这个变量的作用在于获取当前线程池运行状态以及当前线程数(稍后详细说明)<br>通过上面可以将执行的流程分成三部分：</p><ol><li>如果当前工作线程少于corePoolSize，则添加新的核心线程来执行任务，addworker方法会自动检查线程池运行状态以及工作线程数目并且通过返回值来通知是否成功创建线程。</li><li>线程数大于corePoolSize的时候，我们会优先将任务送入workQueue。同时我们仍然需要对线程池状态以及线程数进行二次检查，避免进入该方法时该线程池已经停止接受任务，这时需要将任务从队列中移除并且执行reject操作。如果此时线程池中无可用线程，会创建一个空的非核心线程。</li><li>如果不能往队列中送入任务，那么会让线程池创建一个非核心的线程来执行任务。如果没有创建成功，则执行reject操作。</li></ol><p>具体流程图如下：<br><img src="/assets/blogImg/threadpoolexecutor.png" alt="execute执行流程"></p><p>后续更新…</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> concurrent </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayDeque中allocateElements解析</title>
      <link href="/2018/01/03/ArrayDeque%E4%B8%ADallocateElements%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/01/03/ArrayDeque%E4%B8%ADallocateElements%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>jdk1.7源码如下</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   </span><br><span class="line">            <span class="comment">// Too many elements, must back off</span></span><br><span class="line">            initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        elements = (E[]) <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- more --><p>方法目的在于，当numElements 小于 initialCapacity的时候，直接取默认值 initialCapacity，而大于默认值的时候取 n = 2^k (k 为 32 以内的整数) ，此时 n &gt; numElements。<br>下面简单分析代码：<br>假设 a = 1xxxxxxx xxxxxxxx  (2进制表示 1表示该数的最高位, x代表0或者1)<br>a | a &gt;&gt;&gt; 1    =  11xxxxxx xxxxxxxx  (最高两位为11)<br>a | a &gt;&gt;&gt; 2    =  1111xxxx xxxxxxxx<br>a | a &gt;&gt;&gt; 4    =  11111111 xxxxxxxx<br>a | a &gt;&gt;&gt; 8    =  11111111 11111111<br>……..<br>最终的目的是将表示该数的最高位的1复制到接下来的1位、2位、4位直到16位,保证接下来a的低位全部是1，在加1一位导致高位左移，其余位数变成0，并且是2^k。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReentrantLock(重入锁)以及公平性</title>
      <link href="/2018/01/03/ReentrantLock(%E9%87%8D%E5%85%A5%E9%94%81)%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7/"/>
      <url>/2018/01/03/ReentrantLock(%E9%87%8D%E5%85%A5%E9%94%81)%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>ReentrantLock的实现可以替代隐式的synchronized关键字，而且能够提供超过关键字本身的多种功能。<br>这里有一个锁获取的公平性问题，如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁就是公平的，反之，是不公平的，也就是说等待时间最长的线程最有机会获取锁，也可以说锁的获取是有序的。ReentrantLock提供了一个构造函数，能够控制这个锁是否公平。而锁的名字也是说明了这个锁具备重复进入的可能，也就是说能让当前线程多次的进行对锁的获取操作，这样的最大次数是限制是Integer.MAX_VALUE,约21次左右。<br>事实上公平的锁机制没有非公平的效率高，因为公平的获取锁没有考虑到操作系统对线程的调度因素，这样造成JVM对于等待中的线程调度次序和操作系统对线程的调度之间的不匹配。对于锁的快速且重复获取过程中，连续获取的概率是非常高的，而公平锁会压制这种情况，虽然公平性得以保障，但是响应比却下降了。</p><a id="more"></a><h2 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h2><p>代码结构如下：<br><img src="/assets/blogImg/reentranlock-img01.png" alt="代码结构"></p><p>ReentrantLock持有一个Sync对象,该对象实现了AbstractQueuedSynchronizer，而Sync有两个具化实现类FairSync和NonfairSync。<br>Sync(AbstractQueueSynchronizer)中持有两个Node对象tail和head来维持一张等待线程的链表。</p><p>FairSync和NonfairSync的具体区别点在于：</p><ol><li>lock的时候,FairSync直接调用的acquire(1),当前线程直接进入等待链表中，而NonfairSync则是优先通过compareAndSetState尝试去获取一次锁(修改当前锁的状态)，如果成功则直接拿到锁，不成功则调用acquire(1)进入等待队列。</li><li>tryAcquire时候，FairSync先通过判断前面没有等待线程的时候在进行尝试获取锁，而NonfairSync直接就尝试获取。FairSync执行的顺序完全安装等待队列中的顺序执行，而NonfairSync则是打破这种规则先直接获取，获取的到就可以，获取不到才进入等待队列。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> concurrent </tag>
            
            <tag> synchronize </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
